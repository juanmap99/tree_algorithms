<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modall-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>El Binary Search Tree (Árbol de Búsqueda Binaria) es una estructura fundamental que representa una de las formas más elementales y simples de crear un árbol. Debido a esta simplicidad, suele ser empleado para introducir el concepto de árboles en general.
            </p>
            <p>
                Uno de los aspectos a destacar del Binary Search Tree es que el mismo no cuenta con ningun mecanismo que le permita balancearse, de manera tal que se garantice una altura logarítmica con respecto a la cantidad de nodos. Esta propiedad no es deseable, ya que impacta negativamente en la complejidad temporal del algoritmo.
            </p>
            <br>
            <h1>Estructura y reglas</h1>
            <p>Es relevante destacar que, si bien estas normas son específicas al Binary Search Tree, gran parte de los árboles comparten esta serie de normas básicas.</p>
                <ul>
                    <li>
                        El árbol se encuentra compuesto por nodos.
                    </li>
                    <li>Cada nodo puede tener hasta dos hijos: un hijo derecho y un hijo izquierdo.</li>
                    <li>A lo largo de todo el árbol, se mantiene la propiedad de que todo hijo izquierdo debe tener un valor menor que su padre.</li>
                    <li>De manera consistente en todo el árbol, todo hijo derecho debe tener un valor mayor que su padre.</li>
                    <li>Los nodos que carecen de hijos se denominan nodos hoja(también conocidos como Leaf nodes).</li>
                    <li>Si el árbol no está vacío, siempre tiene un nodo raíz, también llamado root,  desde el cual se puede acceder a la totalidad del árbol.</li>
                </ul>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modall-content"
        [style.height]="modalHeight-90 + 'px'"
        [style.width]="modalWidth-40 + 'px'">
        <h1>Métodos</h1>
            <h1>Add</h1>
            <p>
                El proceso de inserción de un elemento en un Binary Search Tree (BST) se da dos maneras, dependiendo del estado en el que se encuentre el árbol:
            </p>
            <h4><strong>Estado 1 - Árbol vacío</strong></h4>
            <p>Este estado representa el caso más simple . Al agregar un elemento, el elemento a insertar se convierte en la raíz del árbol y el proceso de inserción finaliza.</p>
            <h4><strong>Estado 2 - Árbol no vacío</strong></h4>
            <p>Cuando el árbol no está vacío, el proceso de inserción de un elemento sigue la siguiente secuencia:</p>
            <ul>
                <li>El método de inserción es invocado, recibiendo como parámetro un nodo. En una primera instancia, ese nodo es la raíz del árbol.</li>
                <li>Sobre cada llamada, uno de los siguientes tres casos puede ocurrir:
                    <ul>
                        <li><u>Caso 1:</u>Si el elemento a insertar es mayor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                            <ul>
                                <li>Si el hijo derecho no existe, el nodo a insertar se convierte en el hijo derecho y el proceso de inserción finaliza.</li>
                                <li>Si el hijo derecho existe, la función de inserción se llama recursivamente, estableciendo el hijo derecho como el nuevo nodo focal para la evaluación.</li>
                            </ul>
                        </li>
                        <li><u>Caso 2:</u>Si el elemento a insertar es menor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                            <ul>
                                <li>Si el hijo izquierdo no existe, el nodo a insertar se convierte en el hijo izquierdo y el proceso de inserción finaliza.</li>
                                <li>Si el hijo izquierdo existe, la función de inserción se llama recursivamente, estableciendo el hijo izquierdo como el nuevo nodo focal para la evaluación.</li>
                            </ul>
                        </li>
                        <li><u>Caso 3:</u>Si el elemento a insertar es igual al valor del nodo en el cual se encuentra la ejecución, el elemento a insertar ya se encontraba presente en el árbol y el proceso de inserción finaliza.</li>
                    </ul>
                </li>
            </ul>

            <h1>Search</h1>
            <p>
                En el caso que el árbol no esté vacío, el proceso de búsqueda de un elemento sigue los siguientes pasos:
            </p>
            <ul>
                <li>El método de búsqueda es invocado, recibiendo como parámetro un nodo. En una primera instancia, ese nodo es la raíz del árbol.</li>
                <li>
                    Sobre cada llamada, uno de los siguientes tres casos puede ocurrir:
                    <ul>
                        <li><u>Caso 1:</u> Si el elemento a buscar es mayor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                            <ul>
                                <li>Si el hijo derecho no existe, se puede concluir que el nodo buscado no está en el árbol y se retorna null.</li>
                                <li>Si el hijo derecho existe, la función de búsqueda es llamada recursivamente con el hijo derecho como nuevo nodo actual.</li>
                            </ul>
                        </li>
                        <li><u>Caso 2:</u> Si el elemento a buscar es menor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                            <ul>
                                <li>Si el hijo izquierdo no existe, se puede concluir que el nodo buscado no está en el árbol y se retorna null.</li>
                                <li>Si el hijo izquierdo existe, la función de búsqueda es llamada recursivamente con el hijo izquierdo como nuevo nodo actual.</li>
                            </ul>
                        </li>
                        <li><u>Caso 3:</u>Si el elemento a buscar es igual que el valor del nodo siendo evaluado, el algoritmo finaliza exitosamente retornando el nodo actual como resultado.</li>
                    </ul>
                </li>
            </ul>

            <h1>Find min</h1>
            <p>
                Cuando el árbol no está vacío, el proceso de búsqueda del mínimo sigue la siguiente secuencia:
            </p>
            <ul>
                <li>El método de búsqueda del mínimo es invocado, recibiendo como parámetro un nodo. En una primera instancia, ese nodo es la raíz del árbol.</li>
                <li>En caso de que el nodo posea un hijo izquierdo, la función es llamada recursivamente estableciendo el hijo derecho como el nuevo foco a evaluar.</li>
                <li>En caso de que no exista un hijo izquierdo, el nodo con un valor mínimo fue encontrado. En consecuencia, el algoritmo lo retorna.</li>
            </ul>

            <h1>Find max</h1>
            <p>
                Cuando el árbol no está vacío, el proceso de búsqueda del máximo  sigue la siguiente secuencia:
            </p>
            <ul>
                <li>El método de búsqueda del máximo es invocado, recibiendo como parámetro un nodo. En una primera instancia, ese nodo es la raíz del árbol.</li>
                <li>En caso de que el nodo posea un hijo derecho, la función es llamada recursivamente estableciendo el hijo derecho como el nuevo foco a evaluar.</li>
                <li>En caso de que no exista un hijo derecho, el nodo con un valor máximo fue encontrado. En consecuencia, el algoritmo lo retorna.</li>
            </ul>

            <h1>Delete</h1>
            <p>
                Cuando el árbol no está vacío, el proceso de eliminación de un elemento sigue los siguientes pasos:
            </p>
            <ul>
                <li>El método de eliminación es invocado, recibiendo como parámetro un nodo. En una primera instancia, ese nodo es la raíz del árbol.</li>
                <li>En caso que el foco del elemento a evaluar sea igual a null, se retorna null implicando que el nodo a eliminar no existe en el árbol.</li>
                <li>Sobre cada llamada, uno de los siguientes cuatro casos puede ocurrir:
                    <ul>
                        <li><u>Caso 1:</u>Si el elemento a eliminar es mayor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                        <ul>
                            <li>La función de eliminación es llamada recursivamente con el hijo derecho como nuevo nodo actual.</li>
                            <li>El resultado que la función llamada retorne se convierte en el nuevo hijo derecho.</li>
                        </ul>
                        </li>
                        <li><u>Caso 2:</u>Si el elemento a eliminar es menor que el valor del nodo siendo evaluado, se realiza lo siguiente:
                            <ul>
                                <li>La función de eliminación es llamada recursivamente con el hijo izquierdo como nuevo nodo actual.</li>
                                <li>El resultado que la función llamada retorne se convierte en el nuevo hijo izquierdo.</li>
                            </ul>
                        </li>
                        <li><u>Caso 3:</u>Si el nodo siendo evaluado es null, el nodo a eliminar no existe en el árbol. Debido a ello, y la propia implementación del algoritmo, se retorna null.</li>
                        <li><u>Caso 4:</u>Si el elemento a buscar es igual que el valor del nodo siendo evaluado se efectúa el proceso de eliminación. La manera de proceder depende de la ausencia o no de hijos del nodo a eliminar, el cual por conveniencia a la hora de explicar será llamado nodeToDel:
                            <ul>
                                <li><strong>El nodo a eliminar no posee hijo izquierdo</strong>
                                    <ul>
                                        <li>El hijo derecho se guarda en una variable auxiliar temporal.</li>
                                        <li>nodeToDel se establece como null.</li>
                                        <li>Se retorna la variable auxiliar, finalizando el proceso de eliminación.</li>
                                    </ul>
                                </li>
                                <li><strong>El nodo a eliminar no posee hijo derecho</strong>
                                    <ul>
                                        <li>El hijo izquierdo se guarda en una variable auxiliar temporal.</li>
                                        <li>nodeToDel se establece como null.</li>
                                        <li>Se retorna la variable auxiliar, finalizando el proceso de eliminación.</li>
                                    </ul>
                                </li>
                                <li><strong>El nodo a eliminar no posee hijos</strong>
                                    <ul>
                                        <li>Se retorna null, finalizando el proceso de eliminación. Cabe destacar que, por simplicidad, este caso no suele ser implementado, si no que caerá ante el primer paso evaluado, en donde el hijo derecho guardado en la variable auxiliar que es retornado es null.</li>
                                    </ul>
                                </li>
                                <li><strong>El nodo a eliminar tiene ambos hijos</strong>
                                    <ul>
                                        <li>Se busca el "Inorder successor" (o "Inorder predecessor") del nodo a eliminar. El Inorder successor es el nodo con el valor más pequeño empezando desde el hijo derecho del nodo a eliminar.</li>
                                        <li>Una vez obtenido el mismo, el valor del nodo a eliminar es reemplazado por el del Inorder successor.</li>
                                        <li>Luego, se procede a eliminar el Inorder successor (que ahora está duplicado en el árbol) siguiendo el mismo proceso de eliminación. Debido a que el mismo cuenta como máximo con un hijo derecho, el proceso de eliminación del mismo es sencillo.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <p></p>
            <h1>Complejidad temporal</h1>
            <p>En un escenario ideal, en el cual existe una simetría consistente en las alturas de los hijos derechos e izquierdos en todo el árbol, cada desplazamiento realizado a un nodo hijo provoca que la mitad de los elementos restantes ya no necesiten ser recorridos. Esto da lugar a una complejidad temporal de eliminar, insertar o buscar un elemento de O(log<sub>2</sub> (N)), donde N representa la cantidad de nodos en el árbol.
            </p>
            <p>
                No obstante, debido a que un Binary Search Tree (BST) no se auto-balancea por sí mismo, no puede garantizarse que el árbol se encuentre  balanceado. En situaciones en las que el árbol no está balanceado, la complejidad temporal en el peor caso puede alcanzar O(N), donde N es el número de nodos en el árbol.
            </p>
        </div>
    </div>

    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>
