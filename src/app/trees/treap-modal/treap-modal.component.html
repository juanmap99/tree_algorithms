<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modall-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>El Treap es una estructura de árbol que utiliza la aleatoriedad y una heap para mantener una el balance con una alta probabilidad. Sin embargo, a diferencia del AVL y Red Black Tree, el Treap no garantiza una altura logarítmica con respecto a la cantidad de nodos en el árbol, lo que significa que pueden surgir circunstancias en las que el Treap esté desequilibrado.
            </p>
            <p>   
                Si bien puede utilizarse tanto una Max heap como una Min heap, la explicación se realiza en función del método elegido por la herramienta: Max heap.
            </p>
            <br/><br/>
            <h1>Estructura y reglas</h1>
            <p>Hay ciertos conceptos que es necesario conocer antes de abordar la lógica de cómo funciona un Treap. Estos conceptos incluyen:</p>
            <ul>
                <li>Todas las reglas que se aplican a los Binary Search Tree (BST) también se aplican al Treap.</li>
                <li>Cada nodo tiene una prioridad asignada de manera aleatoria.</li>
                <li>Debe cumplirse que la prioridad de los nodos padres sea mayor que la prioridad de sus nodos hijos. Esta regla es la misma que la Max Heap aplica para con los valores, en donde los nodos padres deben tener valores mayores a los de sus hijos.</li>
                <li>El Treap implementa el concepto de rotaciones izquierdas y derechas de la misma manera que el AVL Tree.</li>
            </ul>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modall-content"
        [style.height]="modalHeight-90 + 'px'"
        [style.width]="modalWidth-40 + 'px'">
        <h1>Métodos</h1>
            <h1>Add</h1>
            <p>El proceso de agregar un nodo en un Treap es relativamente simple en comparación con la complejidad que presenta el Red Black Tree, y consta de los siguientes pasos:</p>
            <ul>
                <li>Como primer paso, el nodo a agregar debe ser insertado en el árbol de la misma manera que se realiza en un BST.</li>
                <li>Una vez que el nodo está insertado, se realiza el siguiente análisis basado en las prioridades del nodo y su padre:
                    <ul>
                        <li><u>Caso 1 - Nodo con prioridad menor que su padre:</u>Si el nodo tiene una prioridad menor que su padre, el proceso de inserción se considera terminado, ya que las reglas del Treap se mantienen sin necesidad de realizar más acciones.</li>
                        <li><u>Caso 2 - Nodo con prioridad mayor que su padre:</u>Si el nodo tiene una prioridad mayor que su padre, se deben realizar rotaciones para garantizar que la propiedad de prioridad se mantenga y que el Treap no pierda su equilibrio. Los pasos son los siguientes:
                        <ul>
                            <li>Si el nodo es el hijo derecho de su padre y tiene una prioridad mayor, el padre rota hacia la izquierda. </li>
                            <li>Si el nodo es el hijo izquierdo de su padre y tiene una prioridad mayor, el padre rota hacia la derecha. </li>
                        </ul>
                        </li>
                        <li>Estas comparaciones y rotaciones, en caso de ser necesarias, se realizan de manera recursiva sobre el tramo recorrido para realizar el insert. Esto garantiza que se mantenga la propiedad de prioridad en todo el árbol y, en consecuencia, que se mantenga, con una alta probabilidad, el equilibrio de la Treap.</li>
                    </ul>
                </li>
            </ul>
            <h1>Search</h1>
            <p>
                La búsqueda de un elemento sobre un Treap es idéntica a la explicada en el BST(Binary Search Tree).
            </p>

            <h1>Find min</h1>
            <p>
                La búsqueda del valor mínimo sobre un Treap es idéntica a la explicada en el BST(Binary Search Tree).
            </p>

            <h1>Find max</h1>
            <p>
                La búsqueda del valor máximo sobre un Treap es idéntica a la explicada en el BST(Binary Search Tree).
            </p>

            <h1>Delete</h1>
            <p>El proceso de eliminar un nodo en un Treap sigue una lógica ligeramente diferente a la del  BST:</p>
            <ul>
                <li>Como primer paso, el nodo a eliminar se busca de la misma manera que se hace en un  BST.</li>
                <li>Si el nodo a eliminar es un nodo hoja o tiene solamente un hijo, el procedimiento es idéntico al caso del BST y se realiza de manera estándar.</li>
                <li>Si el nodo a eliminar es un nodo hoja o tiene solamente un hijo, el procedimiento es idéntico al caso del BST y se realiza de manera estándar.
                    <ul>
                        <li><u>Caso 1 - Hijo izquierdo con mayor prioridad que el derecho:</u>En este caso, el nodo a eliminar debe realizar una rotación hacia la derecha. Esto implica que el hijo izquierdo se convierte en el nuevo padre, y el nodo a eliminar se convierte en el hijo derecho del nuevo padre. Luego, se llama nuevamente a la función de eliminación sobre el nodo a eliminar.</li>
                        <li><u>Caso 2 - Hijo izquierdo con menor prioridad que el derecho:</u>En este caso, el nodo a eliminar debe realizar una rotación hacia la izquierda. Esto significa que el hijo derecho se convierte en el nuevo padre, y el nodo a eliminar se convierte en el hijo izquierdo del nuevo padre. Igualmente, se llama nuevamente a la función sobre el nodo a eliminar.</li>
                    </ul>
                </li>
            </ul>
            <h1>Complejidad Temporal</h1>
                <p>En un escenario ideal, en el cual existe una simetría consistente en las alturas de los hijos derechos e izquierdos en todo el árbol, cada desplazamiento realizado a un nodo hijo durante el proceso de inserción provoca que la mitad de los elementos restantes ya no necesiten ser recorridos. Esto da lugar a una complejidad temporal de agregar, buscar o eliminar un elemento de O(log<sub>2</sub> (N)), donde N representa la cantidad de nodos en el árbol.</p>
                <p>
                    SSin embargo, si bien el Treap es un árbol que se auto balancea, no puede garantizarse que la altura del mismo sea de O(log<sub>2</sub> (N)). Debido a ello, la complejidad temporal ante el peor de los casos,  si bien muy inusual, es de O(N).
                </p>
        </div>
    </div>

    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>